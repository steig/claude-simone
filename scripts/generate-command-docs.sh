#!/bin/bash

# Simone Framework Command Documentation Generator
# Automatically generates command reference documentation from actual command files

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
COMMANDS_DIR=".claude/commands/simone"
OUTPUT_FILE="docs/core-components/command-reference.md"
BACKUP_SUFFIX=".backup.$(date +%Y%m%d_%H%M%S)"

# Utility functions
log() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if running from project root
check_project_root() {
    if [[ ! -d "$COMMANDS_DIR" ]]; then
        error "Simone commands directory not found: $COMMANDS_DIR"
        error "Please run this script from the project root directory"
        exit 1
    fi
    success "Found Simone commands directory"
}

# Parse command metadata from markdown files
parse_command_metadata() {
    local file="$1"
    local command_name=$(basename "$file" .md)
    
    # Extract YAML frontmatter
    local has_frontmatter=false
    local in_frontmatter=false
    local yaml_content=""
    local description=""
    local usage=""
    local parameters=""
    local examples=""
    
    while IFS= read -r line; do
        if [[ "$line" == "---" ]]; then
            if [[ "$has_frontmatter" == false ]]; then
                has_frontmatter=true
                in_frontmatter=true
                continue
            else
                in_frontmatter=false
                continue
            fi
        fi
        
        if [[ "$in_frontmatter" == true ]]; then
            yaml_content+="$line"$'\n'
        fi
    done < "$file"
    
    # Extract description (first paragraph after frontmatter)
    description=$(awk '/^---$/{f=1;next} /^---$/{f=0;next} f && /^$/{if(desc)exit} f && !/^#/ && desc=="" {desc=$0} f && !/^#/ && desc!="" {desc=desc" "$0} END{print desc}' "$file")
    
    # Extract usage pattern
    usage=$(grep -A 5 -i "usage\|syntax" "$file" | grep -E "^\s*\/" | head -1 | sed 's/^[[:space:]]*//')
    
    # If no usage found, try to construct from command name
    if [[ -z "$usage" ]]; then
        usage="/project:simone:$command_name"
    fi
    
    # Extract parameters section
    parameters=$(awk '/^## Parameters/,/^##/ {if(/^## Parameters/) next; if(/^##/ && !/^## Parameters/) exit; print}' "$file")
    
    # Extract examples section
    examples=$(awk '/^## Examples/,/^##/ {if(/^## Examples/) next; if(/^##/ && !/^## Examples/) exit; print}' "$file")
    
    # Output command information in structured format
    echo "COMMAND:$command_name"
    echo "DESCRIPTION:$description"
    echo "USAGE:$usage"
    echo "PARAMETERS:$parameters"
    echo "EXAMPLES:$examples"
    echo "---END---"
}

# Generate markdown documentation
generate_documentation() {
    local output_file="$1"
    local temp_file=$(mktemp)
    
    log "Generating command reference documentation..."
    
    # Write header
    cat > "$temp_file" << 'EOF'
# Simone Framework Command Reference

---
title: "Command Reference"
type: "reference"
category: "core_components"
auto_generated: true
generated_date: "AUTO_GENERATED_DATE"
source: "scripts/generate-command-docs.sh"
maintenance: "Regenerate using scripts/generate-command-docs.sh"
tags: ["commands", "reference", "cli", "auto-generated"]
---

## Overview

This document provides comprehensive reference documentation for all Simone Framework commands. This documentation is auto-generated from the actual command files to ensure accuracy and completeness.

**ðŸ¤– Auto-Generated**: This file is automatically generated from command definitions in `.claude/commands/simone/`. Do not edit manually - changes will be overwritten.

**Last Generated**: AUTO_GENERATED_DATE  
**Source**: .claude/commands/simone/*.md  
**Generator**: scripts/generate-command-docs.sh

## Command Categories

### Project Management Commands
Commands for managing Simone projects, milestones, and sprints.

### Task Management Commands  
Commands for creating, updating, and tracking individual tasks.

### Quality & Review Commands
Commands for code review, quality assurance, and compliance checking.

### Utility Commands
Helper commands for project maintenance and automation.

---

## Available Commands

EOF

    # Replace placeholder with actual date
    sed -i.tmp "s/AUTO_GENERATED_DATE/$(date '+%Y-%m-%d %H:%M:%S')/g" "$temp_file" && rm "$temp_file.tmp"
    
    # Process each command file
    local command_count=0
    local processed_commands=()
    
    # Get sorted list of command files
    local command_files
    mapfile -t command_files < <(find "$COMMANDS_DIR" -name "*.md" -type f | sort)
    
    for cmd_file in "${command_files[@]}"; do
        local command_name=$(basename "$cmd_file" .md)
        log "Processing command: $command_name"
        
        # Parse command metadata
        local cmd_data=$(parse_command_metadata "$cmd_file")
        
        # Extract components
        local description=$(echo "$cmd_data" | awk -F: '/^DESCRIPTION:/ {print substr($0, 13)}')
        local usage=$(echo "$cmd_data" | awk -F: '/^USAGE:/ {print substr($0, 7)}')
        local parameters=$(echo "$cmd_data" | awk '/^PARAMETERS:/,/^EXAMPLES:/ {if(!/^PARAMETERS:/ && !/^EXAMPLES:/) print}')
        local examples=$(echo "$cmd_data" | awk '/^EXAMPLES:/,/^---END---/ {if(!/^EXAMPLES:/ && !/^---END---/) print}')
        
        # Generate command section
        cat >> "$temp_file" << EOF

### \`$command_name\`

**Description**: $description

**Usage**:
\`\`\`
$usage
\`\`\`

EOF

        # Add parameters if they exist
        if [[ -n "$parameters" && "$parameters" != "" ]]; then
            echo "**Parameters**:" >> "$temp_file"
            echo "$parameters" >> "$temp_file"
            echo >> "$temp_file"
        fi
        
        # Add examples if they exist
        if [[ -n "$examples" && "$examples" != "" ]]; then
            echo "**Examples**:" >> "$temp_file"
            echo "$examples" >> "$temp_file"
            echo >> "$temp_file"
        fi
        
        # Add source reference
        echo "**Source**: [\`$cmd_file\`]($cmd_file)" >> "$temp_file"
        echo >> "$temp_file"
        echo "---" >> "$temp_file"
        
        processed_commands+=("$command_name")
        ((command_count++))
    done
    
    # Add footer with summary
    cat >> "$temp_file" << EOF

## Command Summary

**Total Commands**: $command_count  
**Categories**: Project Management, Task Management, Quality & Review, Utilities

### Alphabetical Index
EOF

    # Generate alphabetical index
    for cmd in "${processed_commands[@]}"; do
        echo "- [\`$cmd\`](#$(echo "$cmd" | tr '[:upper:]' '[:lower:]' | tr '_' '-'))" >> "$temp_file"
    done
    
    cat >> "$temp_file" << EOF

## Usage Patterns

### Common Command Patterns
\`\`\`bash
# Project initialization
/project:simone:init_project

# Create new milestone
/project:simone:create_milestone

# Add tasks to current sprint
/project:simone:add_task

# Review and quality check
/project:simone:code_review
\`\`\`

### Command Chaining
Many Simone commands can be chained together for efficient workflows:
\`\`\`bash
# Create milestone and immediately add first sprint
/project:simone:create_milestone "User Authentication"
/project:simone:create_sprint "Auth Backend Implementation"
\`\`\`

## Getting Help

For detailed help on any command:
\`\`\`bash
/project:simone:[command_name] --help
\`\`\`

For general Simone help:
\`\`\`bash
/project:simone:help
\`\`\`

## Related Documentation

- [Quick Start Guide](../getting-started/quick-start.md) - Get started with Simone
- [Template System](template-system.md) - Understanding Simone templates
- [Project Structure](project-structure.md) - Simone directory organization
- [Best Practices](../best-practices/) - Command usage best practices

---

**Auto-Generation Info**:
- **Generated**: $(date '+%Y-%m-%d %H:%M:%S')
- **Generator**: scripts/generate-command-docs.sh
- **Source Files**: $command_count command files in $COMMANDS_DIR
- **Last Updated**: This file is regenerated on each script run

**Maintenance**: To update this documentation, run:
\`\`\`bash
./scripts/generate-command-docs.sh
\`\`\`
EOF

    # Move temp file to final location
    mv "$temp_file" "$output_file"
    success "Generated documentation with $command_count commands"
}

# Backup existing documentation
backup_existing_docs() {
    if [[ -f "$OUTPUT_FILE" ]]; then
        cp "$OUTPUT_FILE" "${OUTPUT_FILE}${BACKUP_SUFFIX}"
        success "Backed up existing documentation to ${OUTPUT_FILE}${BACKUP_SUFFIX}"
    fi
}

# Validate generated documentation
validate_documentation() {
    local output_file="$1"
    
    log "Validating generated documentation..."
    
    # Check if file was created
    if [[ ! -f "$output_file" ]]; then
        error "Generated documentation file not found: $output_file"
        return 1
    fi
    
    # Check if file has content
    local line_count=$(wc -l < "$output_file")
    if [[ "$line_count" -lt 50 ]]; then
        warn "Generated documentation seems too short ($line_count lines)"
    else
        success "Generated documentation has $line_count lines"
    fi
    
    # Check for basic structure
    if grep -q "# Simone Framework Command Reference" "$output_file"; then
        success "Documentation has proper header"
    else
        error "Documentation missing proper header"
        return 1
    fi
    
    # Check for command sections
    local command_sections=$(grep -c "^### \`.*\`$" "$output_file")
    if [[ "$command_sections" -gt 0 ]]; then
        success "Found $command_sections command sections"
    else
        error "No command sections found in documentation"
        return 1
    fi
    
    return 0
}

# Generate command statistics
generate_statistics() {
    log "Generating command statistics..."
    
    local total_commands=$(find "$COMMANDS_DIR" -name "*.md" -type f | wc -l)
    local total_size=$(du -sh "$COMMANDS_DIR" | cut -f1)
    local avg_file_size=$(find "$COMMANDS_DIR" -name "*.md" -type f -exec wc -l {} + | tail -1 | awk '{print int($1/'$total_commands')}')
    
    echo
    echo -e "${BLUE}=== COMMAND STATISTICS ===${NC}"
    echo -e "${GREEN}Total Commands:${NC} $total_commands"
    echo -e "${GREEN}Source Directory Size:${NC} $total_size"
    echo -e "${GREEN}Average Command File Size:${NC} $avg_file_size lines"
    echo -e "${GREEN}Output File:${NC} $OUTPUT_FILE"
    echo
}

# Main execution
main() {
    echo -e "${BLUE}ðŸ”„ Simone Command Documentation Generator${NC}"
    echo -e "${BLUE}=======================================${NC}"
    echo
    
    # Verify environment
    check_project_root
    
    # Create output directory if needed
    mkdir -p "$(dirname "$OUTPUT_FILE")"
    
    # Backup existing documentation
    backup_existing_docs
    
    # Generate new documentation
    generate_documentation "$OUTPUT_FILE"
    
    # Validate generated documentation
    if validate_documentation "$OUTPUT_FILE"; then
        success "Documentation generated successfully: $OUTPUT_FILE"
    else
        error "Documentation validation failed"
        exit 1
    fi
    
    # Show statistics
    generate_statistics
    
    echo -e "${GREEN}âœ… Command documentation generation complete!${NC}"
    echo
    echo "Next steps:"
    echo "1. Review the generated documentation: $OUTPUT_FILE"
    echo "2. Commit the updated documentation to version control"
    echo "3. Set up automation to regenerate when commands change"
}

# Handle command line arguments
case "${1:-}" in
    --help|-h)
        echo "Simone Command Documentation Generator"
        echo
        echo "Usage: $0 [options]"
        echo
        echo "Options:"
        echo "  --help, -h     Show this help message"
        echo "  --dry-run      Show what would be generated without writing files"
        echo "  --stats-only   Show command statistics without generating docs"
        echo
        echo "Output:"
        echo "  $OUTPUT_FILE"
        echo
        echo "This script automatically generates command reference documentation"
        echo "from the actual command files in $COMMANDS_DIR"
        exit 0
        ;;
    --dry-run)
        echo "DRY RUN MODE - No files will be modified"
        check_project_root
        
        local command_files
        mapfile -t command_files < <(find "$COMMANDS_DIR" -name "*.md" -type f | sort)
        
        echo "Would process ${#command_files[@]} command files:"
        for file in "${command_files[@]}"; do
            echo "  - $(basename "$file" .md)"
        done
        echo
        echo "Would generate: $OUTPUT_FILE"
        exit 0
        ;;
    --stats-only)
        check_project_root
        generate_statistics
        exit 0
        ;;
    "")
        # No arguments - run normally
        ;;
    *)
        echo "Unknown option: $1. Use --help for usage information."
        exit 1
        ;;
esac

# Run main function
main